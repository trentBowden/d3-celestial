/**
 * Generated by ChatGPT Based on Celestial.js
 */

import * as d3 from "d3";
import * as geojson from "geojson";
import { FeatureCollection, Geometry } from "geojson";
// import {
//   ZoomBehavior,
//   GeoPath,
//   GeoProjection,
//   GeoPermissibleObjects,
//   D3ZoomEvent,
// } from "d3";
// import {
//   ZoomBehaviour,
//   GeoPath,
//   GeoProjection,
//   GeoPermissibleObjects,
//   D3ZoomEvent,
// } from "@types/d3";
import { ZoomTransform } from "d3-zoom";

class Celestial {
  version: string = "0.7.26";
  container: d3.Selection<any, unknown, HTMLElement, any> | null = null;
  data: any[] = [];
  zoomBehavior: d3.ZoomBehavior<Element, unknown> | null = null;

  constructor() {}

  /**
   * Display the celestial map with a given configuration.
   * @param cfg Configuration object defining celestial display properties.
   */
  display(cfg: CelestialConfig): void {
    const width = cfg.width;
    const height = width / 2;
    const projection = this.getProjection(cfg.projection, cfg.zoomlevel);
    const path: d3.GeoPath<any, d3.GeoPermissibleObjects> = d3
      .geoPath()
      .projection(projection);

    if (this.container) {
      this.container.remove(); // Clear existing container
    }

    this.container = d3
      .select(`#${cfg.container}`)
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    this.setupGraticule(cfg, path);
    this.addStars(cfg, path);
    this.drawConstellations(cfg, path);

    if (cfg.interactive) {
      this.enableMouseRotation(cfg);
    }

    if (cfg.location) {
      this.displayLocation();
    }
  }

  /**
   * Setup graticule (grid lines for latitude and longitude) on the map.
   * @param cfg Configuration object.
   * @param path D3 GeoPath generator.
   */
  setupGraticule(
    cfg: CelestialConfig,
    path: d3.GeoPath<any, d3.GeoPermissibleObjects>
  ): void {
    if (!this.container) return;

    const graticule = d3.geoGraticule().step([10, 10]);

    this.container
      .append("g")
      .attr("class", "graticule")
      .append("path")
      .datum(graticule)
      .attr("d", path)
      .style("fill", "none")
      .style("stroke", "#cccccc")
      .style("stroke-width", "0.5px");
  }

  /**
   * Add stars to the celestial map.
   * @param cfg Configuration object.
   * @param path D3 GeoPath generator.
   */
  addStars(
    cfg: CelestialConfig,
    path: d3.GeoPath<any, d3.GeoPermissibleObjects>
  ): void {
    if (!this.container) return;

    d3.json("data/stars.json").then((data: geojson.FeatureCollection) => {
      this.container
        ?.append("g")
        .selectAll("path")
        .data(data.features)
        .enter()
        .append("path")
        .attr("class", "star")
        .attr("d", path)
        .style("fill", (d) => d.properties?.color || "#ffffff")
        .style("opacity", (d) => d.properties?.magnitude || 1)
        .on("mouseover", (event, d) => {
          // Display star name on hover
          console.log(`Star: ${d.properties?.name}`);
        });
    });
  }

  /**
   * Draw constellations on the celestial map.
   * @param cfg Configuration object.
   * @param path D3 GeoPath generator.
   */
  drawConstellations(
    cfg: CelestialConfig,
    path: d3.GeoPath<any, d3.GeoPermissibleObjects>
  ): void {
    if (!this.container) return;

    d3.json("data/constellations.json").then(
      (data: geojson.FeatureCollection) => {
        this.container
          ?.append("g")
          .selectAll("path")
          .data(data.features)
          .enter()
          .append("path")
          .attr("class", "constellation")
          .attr("d", path)
          .style("stroke", "#ffa500")
          .style("stroke-width", 2)
          .style("fill", "none");
      }
    );
  }

  /**
   * Return the D3 projection for the celestial map based on the configuration.
   * @param projectionType The type of projection to use (e.g., 'orthographic').
   * @param zoomLevel The zoom level for the projection.
   * @returns D3 GeoProjection object.
   */
  getProjection(projectionType: string, zoomLevel: number): d3.GeoProjection {
    let projection: d3.GeoProjection;
    switch (projectionType) {
      case "aitoff":
        throw new Error("aitoff projection not yet supported");
        break;
      case "mercator":
        projection = d3.geoMercator();
        break;
      case "orthographic":
        projection = d3.geoOrthographic();
        break;
      case "equirectangular":
        projection = d3.geoEquirectangular();
        break;
      default:
        throw new Error("invalid projection type");
    }
    return projection.scale(zoomLevel * 1000); // Scale the projection based on zoom level
  }

  /**
   * Enable mouse rotation for the celestial map.
   * @param cfg Configuration object.
   */
  enableMouseRotation(cfg: CelestialConfig): void {
    if (!this.container) return;

    const width = cfg.width;
    const height = width / 2;
    const projection = this.getProjection(cfg.projection, cfg.zoomlevel);
    const path = d3.geoPath().projection(projection);

    // Set up zoom behavior
    this.zoomBehavior = d3
      .zoom<SVGSVGElement, unknown>()
      .scaleExtent([1, 8])
      .on("zoom", (event: d3.D3ZoomEvent<SVGSVGElement, unknown>) => {
        const transform: ZoomTransform = event.transform;
        const newScale = transform.k;
        projection.scale(newScale * 1000);
        this.container?.selectAll("path").attr("d", path);
      });

    // Apply zoom behavior to the SVG container
    this.container.call(this.zoomBehavior);

    // Allow rotation
    const drag = d3
      .drag<SVGSVGElement, unknown>()
      .on("drag", (event: d3.D3DragEvent<SVGSVGElement, unknown, unknown>) => {
        const rotate = projection.rotate();
        const dx = event.dx;
        const dy = event.dy;

        const newRotation = [rotate[0] + dx / 4, rotate[1] - dy / 4];
        projection.rotate(newRotation as [number, number, number]);

        this.container?.selectAll("path").attr("d", path);
      });

    this.container.call(drag);
  }

  /**
   * Display the location of the observer on the celestial map (if enabled in configuration).
   */
  displayLocation(): void {
    if (!this.container) return;

    // Display observer location (e.g., via a marker)
    d3.json("data/location.json").then((data: FeatureCollection) => {
      const projection = this.getProjection("orthographic", 1);
      const path = d3.geoPath().projection(projection);

      this.container
        ?.append("g")
        .selectAll("circle")
        .data(data.features)
        .enter()
        .append("circle")
        .attr("class", "location-marker")
        .attr("cx", (d) => projection(d.geometry.coordinates)[0])
        .attr("cy", (d) => projection(d.geometry.coordinates)[1])
        .attr("r", 5)
        .style("fill", "red");
    });
  }

  /**
   * Reset the zoom to the initial state.
   */
  resetZoom(): void {
    if (!this.container || !this.zoomBehavior) return;

    this.container
      .transition()
      .duration(750)
      .call(this.zoomBehavior.transform, d3.zoomIdentity);
  }
}

// CelestialConfig interface defining the shape of the configuration object
interface CelestialConfig {
  width: number;
  container: string;
  projection: string;
  zoomlevel: number;
  interactive: boolean;
  location?: boolean;
}

// Initialize the Celestial map
const celestial = new Celestial();
const config: CelestialConfig = {
  width: 1000,
  container: "celestial-map",
  projection: "orthographic",
  zoomlevel: 1,
  interactive: true,
  location: true,
};

// Display the celestial map using the configuration
celestial.display(config);
